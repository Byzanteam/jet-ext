defmodule JetExt.Ecto.Schemaless.Schema do
  @moduledoc false

  use TypedStruct

  @typep options() :: [
           source: Ecto.Schema.source(),
           prefix: Ecto.Schema.prefix(),
           primary_key: [atom()],
           autogenerate: [autogenerate_option()],
           autoupdate: [autogenerate_option()],
           constraints: [Ecto.Changeset.constraint()]
         ]

  @typep autogenerate_option() ::
           {fields :: [atom()], generator :: {module(), fun :: atom(), args :: [term()]}}

  @type row() :: map()

  typedstruct do
    field :types, Ecto.Changeset.types(), enforce: true
    field :source, Ecto.Schema.source(), enforce: true
    field :prefix, Ecto.Schema.prefix()
    field :primary_key, [atom()], enforce: true
    field :autogenerate, [autogenerate_option()]
    field :autoupdate, [autogenerate_option()]
    field :constraints, [Ecto.Changeset.constraint()]
  end

  @spec new(Ecto.Changeset.types(), options()) :: t()
  def new(types, options) do
    source = Keyword.fetch!(options, :source)
    prefix = Keyword.get(options, :prefix)
    primary_key = Keyword.fetch!(options, :primary_key)
    autogenerate = Keyword.get(options, :autogenerate, [])
    autoupdate = Keyword.get(options, :autoupdate, [])
    constraints = Keyword.get(options, :constraints, [])

    %__MODULE__{
      types: types,
      source: source,
      prefix: prefix,
      primary_key: primary_key,
      autogenerate: autogenerate,
      autoupdate: autoupdate,
      constraints: constraints
    }
  end

  @spec changeset(t(), data :: map(), params :: map(), permitted :: nil | [atom()]) ::
          Ecto.Changeset.t(row())
  def changeset(%__MODULE__{} = schema, data \\ %{}, params, permitted \\ nil) do
    permitted = permitted || Map.keys(schema.types)

    # https://www.notion.so/byzanteam/Form-Metal-1959b7eda1d34f349d2106a9f9838844?pvs=4#f39c5c2599e8477e9c6fb2049b102a18
    Ecto.Changeset.cast({data, schema.types}, params, permitted,
      empty_values: [[] | Ecto.Changeset.empty_values()]
    )
  end

  @spec load(t(), data :: map()) :: row()
  def load(%__MODULE__{} = schema, data) do
    Map.new(schema.types, fn {field, type} ->
      value = JetExt.Map.indifferent_get(data, field)
      {:ok, value} = Ecto.Type.load(type, value)
      {field, value}
    end)
  end

  @spec dump(t(), row()) :: map()
  def dump(%__MODULE__{} = schema, row) do
    Map.new(schema.types, fn {field, type} ->
      value = Map.get(row, field)
      {:ok, value} = Ecto.Type.dump(type, value)
      {field, value}
    end)
  end

  @spec primary_key(t(), row() | Ecto.Changeset.t(row())) :: keyword()
  def primary_key(%__MODULE__{} = schema, %Ecto.Changeset{} = changeset) do
    Enum.map(schema.primary_key, fn field ->
      {field, Ecto.Changeset.fetch_field!(changeset, field)}
    end)
  end

  def primary_key(%__MODULE__{} = schema, row) do
    Enum.map(schema.primary_key, fn field ->
      {field, Map.fetch!(row, field)}
    end)
  end

  @spec autogenerate_changes(t(), changeset) :: changeset when changeset: Ecto.Changeset.t(row())
  def autogenerate_changes(%__MODULE__{} = schema, %Ecto.Changeset{action: :insert} = changeset) do
    put_autogenerated_changes(changeset, schema.autogenerate, {Ecto.Changeset, :fetch_field, []})
  end

  def autogenerate_changes(%__MODULE__{} = schema, %Ecto.Changeset{action: :update} = changeset) do
    put_autogenerated_changes(changeset, schema.autoupdate, {Ecto.Changeset, :fetch_change, []})
  end

  defp put_autogenerated_changes(changeset, options, fun) do
    Enum.reduce(options, changeset, fn {fields, generator}, acc ->
      put_new_changes_lazy(acc, %{fields => fn -> generate_value(generator) end}, fun)
    end)
  end

  defp generate_value({module, fun, args}) do
    apply(module, fun, args)
  end

  defp put_new_changes_lazy(changeset, changes, fetch_change_fun) do
    Enum.reduce(changes, changeset, fn {fields, generator_fun}, acc ->
      put_new_change_lazy(acc, fields, generator_fun, fetch_change_fun)
    end)
  end

  defp put_new_change_lazy(
         changeset,
         [field | fields],
         fun_or_computed,
         {mod, fun, args} = fetch_change_fun
       ) do
    case apply(mod, fun, [changeset, field | args]) do
      :error ->
        computed = compute_value(fun_or_computed)

        changeset
        |> Ecto.Changeset.put_change(field, computed)
        |> put_new_change_lazy(fields, computed, fetch_change_fun)

      _otherwise ->
        put_new_change_lazy(changeset, fields, fun_or_computed, fetch_change_fun)
    end
  end

  defp put_new_change_lazy(changeset, [], _fun_or_computed, _fetch_change_fun), do: changeset

  defp compute_value(fun) when is_function(fun, 0), do: fun.()
  defp compute_value(computed), do: computed
end
